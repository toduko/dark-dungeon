MOVEMENT_SPEED = 100
MAX_ATTACK_TIMER = 50
attack_timer = 0
walking = false

function init(self)
	msg.post(".", "acquire_input_focus")
	self.vel = vmath.vector3()
end

local function handle_walking_anim()
	if not walking then
		walking = true
		sprite.play_flipbook("#sprite", "walking")
	end
end

local function attack()
	if attack_timer == 0 then
		sprite.play_flipbook("#sprite", "attacking")
		attack_timer = MAX_ATTACK_TIMER
		walking = false
	end
end

function on_message(self, message_id, message, sender)
	-- special message sent only when 2 kinematic or dynamic bodies collide
	if message_id == hash("contact_point_response")
	-- checks the group that should take dmg
	and message.group == hash("skeleton")
	-- checks for the collider's group and enables only the weapons to make the attack
	and sender.fragment == hash("weapon_collision") 
	-- registers only one attack instead of many
	and attack_timer == MAX_ATTACK_TIMER - 1  then
		print("Attacked skeleton")
	end
end

function update(self, dt)
	local pos = go.get_position()
	pos = pos + self.vel * dt
	go.set_position(pos)

	if attack_timer > 0 then
		attack_timer = attack_timer - 1
	end
	
	if self.vel.x ~= 0 or self.vel.y ~= 0 then
		if attack_timer == 0 then
			handle_walking_anim()
		end
	else
		walking = false
		if attack_timer == 0 then
			sprite.play_flipbook("#sprite", "idle")
		end
	end
	
	self.vel.x = 0
	self.vel.y = 0
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.vel.y = MOVEMENT_SPEED
	elseif action_id == hash("down") then
		self.vel.y = -MOVEMENT_SPEED
	elseif action_id == hash("left") then
		self.vel.x = -MOVEMENT_SPEED
		sprite.set_hflip("#sprite", true)
		physics.set_hflip("#weapon_collision", true)
	elseif action_id == hash("right") then
		self.vel.x = MOVEMENT_SPEED
		sprite.set_hflip("#sprite", false)
		physics.set_hflip("#weapon_collision", false)
	elseif action_id == hash("attack") or action_id == hash("touch") then
		attack()
	end
end